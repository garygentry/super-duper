# CLAUDE.md — WinUI 3 C# Application

The WinUI 3 C# project is the Windows UI for Super Duper. It consumes the Rust core library
via P/Invoke (`super_duper_ffi.dll`). Architecture: MVVM with CommunityToolkit.Mvvm.
DI via `Microsoft.Extensions.DependencyInjection`. Target: .NET 10 + WinAppSDK 1.8, x64 + ARM64.

## Build Commands

```bash
cd ui/windows/SuperDuper && dotnet build
# BuildNativeDll target in SuperDuper.csproj automatically runs:
#   cargo build -p super-duper-ffi
# before C# compilation. Rust toolchain must be on PATH.
# The DLL is copied to output alongside the .exe automatically.
```

---

## CRITICAL: XAML Compiler Workarounds (.NET 10 + WinAppSDK 1.8)

**These workarounds are what keep the build working. Breaking any of them breaks the build.**

### What works (do not remove)

- `.g.cs` files generated by XAML compiler pass 1 — `IComponentConnector` wires x:Name fields correctly.
- `XamlTypeInfo.g.cs` (~5500 lines) auto-generated by pass 2 — do NOT create a manual `IXamlMetadataProvider`.
- Event handler attributes **inside `<DataTemplate>`** (`Click="..."`, `PointerPressed="..."`) — safe in XAML; wired by the generated `Connect()` inside DataTemplate blocks.

### What requires workarounds (do not remove or bypass)

**1. `Directory.Build.targets` — XAML compiler exit code wrapper**

WinAppSDK 1.8's `XamlCompiler.exe` always returns exit code 1 on .NET 10 even when all passes
succeed. The `_GenerateXamlCompilerWrapper` target generates `build/_xaml_wrapper.cmd` which
calls the real compiler and forces `exit /b 0`. Without this, the entire C# build fails.
Remove when WinAppSDK ships a .NET 10-compatible compiler.

**2. `<DisableXbfGeneration>true</DisableXbfGeneration>` in SuperDuper.csproj**

Disables pre-compiled XBF generation; XAML files are loaded raw at runtime instead.
This is what allows the app to run despite pass 2 exiting 1. Do not remove.

**3. `_CopyXamlSourcesToIntermediateDir` in `Directory.Build.targets`**

With `DisableXbfGeneration=true`, `CopyGeneratedXaml` expects `.xaml` files in the
intermediate directory. Since pass 2's exit code 1 skips the normal copy, this target
copies `.xaml` files manually after `MarkupCompilePass2`. Do not remove.

**4. Use `{Binding}` — NOT `{x:Bind}`**

Compile-time `x:Bind` code generation is unreliable under `DisableXbfGeneration=true`.
All bindings throughout this project use `{Binding}`.

**5. Do NOT use `x:DataType` on DataTemplates**

The runtime XAML parser does not understand `x:DataType`. Omit it entirely.

**6. All `Application.Resources` must be in `App.xaml`**

`Application.Resources` getter/setter throw `COMException` (`E_UNEXPECTED`) in code-behind
on .NET 10. All styles, brushes, and converters are declared as resources in `App.xaml` only.
Do not add resources programmatically or in merged dictionaries outside `App.xaml`.

**7. Page-level event handlers must be wired in the constructor — not XAML**

`Click="..."`, `SelectionChanged="..."`, `Toggled="..."`, `TextChanged="..."` on elements
outside a `<DataTemplate>` cause XAML compiler pass 2 to fail with an empty `.g.cs` file.

**8. Custom UserControl events must be wired in the consuming page's constructor — not XAML**

Events like `NodeClicked`, `SelectedDirectoryChanged`, `SelectedFileChanged` on control
elements in XAML will break the build. Wire them in the host page's constructor.

### THE RULE (one line)

> **Never add event handler attributes to non-DataTemplate XAML elements. DataTemplate events
> only. All others go in the code-behind constructor.**

### XamlHelper.ConnectNamedElements

After every `InitializeComponent()` call, `x:Name` fields are wired via reflection:

```csharp
// In a Page or UserControl:
XamlHelper.ConnectNamedElements(this, this);

// In MainWindow (Window is not a FrameworkElement):
XamlHelper.ConnectNamedElements(this, (FrameworkElement)Content);
```

This replaces the `IComponentConnector.Connect()` that pass 2 would normally generate.
Defined in `XamlTypeInfo.cs`. Remove when WinAppSDK ships a working .NET 10 compiler.

---

## Project Structure

```
App.xaml / App.xaml.cs           # Root app; DI in ConfigureServices(); ALL resources here
MainWindow.xaml / MainWindow.xaml.cs  # NavigationView shell; built entirely in BuildNavigationView()
XamlTypeInfo.cs                   # XamlHelper.ConnectNamedElements (reflection x:Name wiring)
Directory.Build.targets           # XAML compiler wrapper + manual XAML copy (do not modify)
SuperDuper.csproj                 # .NET 10, WinAppSDK 1.8, LangVersion=preview (for Mvvm Toolkit)

Controls/
  ComparisonPane.xaml.cs          — Side-by-side duplicate file comparison
  DensityBadge.xaml.cs            — Density indicator (Low/Med/High) for directory nodes
  DirectoryTreeControl.xaml.cs    — Hierarchical dir browser (lazy-loads children)
                                    Custom event: SelectedDirectoryChanged
  DuplicateCard.xaml.cs           — Keep/Delete/Skip decision card for one duplicate
  FileListControl.xaml.cs         — Paginated flat file table for a directory
                                    Custom event: SelectedFileChanged
  ScanProgressOverlay.xaml.cs     — Full-window scan progress; binds to ScanService
  StorageTreemap.xaml.cs          — Treemap disk usage visualization
                                    Custom event: NodeClicked

Views/
  DashboardPage.xaml.cs           — Metrics, scan targets, session picker, inline scan launch
  ExplorerPage.xaml.cs            — Browse directory tree; view duplicates in context
  GroupsPage.xaml.cs              — All duplicate groups; filtering, sorting, pagination
  DirectoriesPage.xaml.cs         — Similar directory pairs from Rust directory analysis
  DeletionReviewPage.xaml.cs      — Mark files/dirs for deletion; execute plan
  ScanDialog.xaml.cs              — Configure scan paths + ignore patterns; run scan
  DeletionConfirmationDialog.xaml.cs — Final review before actual deletion executes
  SettingsPage.xaml.cs            — App preferences (theme, deletion mode, etc.)

ViewModels/
  ShellViewModel.cs               — Global: undo/redo state, deletion queue count
  DashboardViewModel.cs           — Metrics, scan targets, session picker, quick wins, treemap
  GroupsViewModel.cs              — Duplicate groups: filtering, sorting, pagination
  ExplorerViewModel.cs            — Selected directory + file state
  DirectoriesViewModel.cs         — Similar directory pair display + compare action
  ScanDialogViewModel.cs          — Scan config form + progress callback marshalling
  DeletionReviewViewModel.cs      — Mark-for-deletion workflow (instantiated directly, not DI)
  ComparisonPaneViewModel.cs      — Side-by-side comparison logic (instantiated directly)
  DirectoryComparisonViewModel.cs — Directory diff logic (instantiated directly)
  DuplicateCardViewModel.cs       — Single card: age, decisions, sibling context (instantiated directly)
  SessionsViewModel.cs            — Session list management (instantiated directly)

Services/
  ScanService.cs                  — CENTRAL SINGLETON: scan execution, progress, active session
                                    All pages subscribe to ScanService.PropertyChanged
                                    and ScanService.ActiveSessionChanged
  DatabaseService.cs              — C#-owned SQLite tables: review_decisions, undo_log, scan_profiles
                                    Opens same super_duper.db as Rust; WAL + busy_timeout=5000
  IDatabaseService.cs             — Interface for DatabaseService
  UndoService.cs / IUndoService.cs — In-memory undo/redo stack (200-entry cap, linked lists)
  SettingsService.cs              — JSON settings at %LocalAppData%\SuperDuper\settings.json
  SuggestionEngine.cs             — Smart deletion recommendation heuristics
  DriveColorService.cs            — Drive letter → accent color mapping
  Platform/Windows/
    WindowsFilePickerService.cs   — StorageFile folder/file pickers
    WindowsNotificationService.cs — Toast notifications via AppNotificationManager
    WindowsShellService.cs        — Reveal in Explorer, shell context menu

NativeMethods/
  SuperDuperEngine.cs             — 70+ P/Invoke declarations; must match super_duper.h exactly
  EngineWrapper.cs                — Managed wrapper: handle lifecycle, marshalling, managed DTOs
                                    ALL native calls go through EngineWrapper.
                                    Never call SuperDuperEngine methods directly from ViewModels.

Models/
  DatabaseModels.cs               — DbFileInfo, DbGroupInfo, QuickWinItem, TreemapNode
  Enums.cs                        — AppTheme, DeletionMode, ReviewStatus, FilterType, etc.
  FilterChip.cs                   — Active filter state for GroupsPage
  UndoActions.cs                  — IUndoableAction implementations (SetDecision, BulkDecision, DirMark)
  SessionPickerItem.cs            — Display model for session picker combobox
  ScanProfile.cs                  — Named/saved scan configuration

Converters/
  FileSizeConverter.cs            — long bytes → "1.2 MB"
  DensityToColorConverter.cs      — density ratio → color brush
  ReviewStatusToIconConverter.cs  — ReviewStatus → glyph string
  InvertBoolConverter.cs          — bool negation

Styles/
  Colors.xaml                     — Brand colors + action brushes (referenced from App.xaml)
  SharedStyles.xaml               — PathTextStyle (Consolas 11pt), CardBorderStyle (8px corner)
```

---

## DI and Service Architecture

Configured in `App.ConfigureServices()` (see `App.xaml.cs`):

**Singletons:**
```
EngineWrapper                      — wraps the native FFI handle; one handle for app lifetime
IDatabaseService / DatabaseService — C#-side SQLite (review_decisions, undo_log, scan_profiles)
IUndoService / UndoService         — in-memory undo/redo stack
SettingsService                    — JSON settings
SuggestionEngine                   — deletion recommendations
DriveColorService                  — drive letter → color
ScanService                        — scan execution + progress + active session
IShellIntegrationService / WindowsShellService
INotificationService / WindowsNotificationService
IFilePickerService / WindowsFilePickerService
```

**Transients (fresh instance per page navigation):**
```
ShellViewModel, DashboardViewModel, ScanDialogViewModel,
ExplorerViewModel, GroupsViewModel, DirectoriesViewModel
```

**Instantiated directly (not registered in DI):**
```
DeletionReviewViewModel, ComparisonPaneViewModel, DirectoryComparisonViewModel,
DuplicateCardViewModel, SessionsViewModel
```

Resolve in page constructors:
```csharp
ViewModel = App.Services.GetRequiredService<MyViewModel>();
```

---

## MVVM Patterns (CommunityToolkit.Mvvm 8.4)

`LangVersion=preview` is required in the `.csproj` for partial property source generators on .NET 10.

```csharp
// Auto-generates public property + INotifyPropertyChanged
[ObservableProperty]
public partial string MyProp { get; set; } = "";

// Cascade change notification to dependent computed properties
[ObservableProperty]
[NotifyPropertyChangedFor(nameof(DisplayLabel))]
public partial bool IsLoading { get; set; }

// Generate ICommand from async Task method
[RelayCommand]
private async Task LoadDataAsync() { ... }

// XAML bindings — always {Binding}, never {x:Bind}
// <TextBlock Text="{Binding ViewModel.MyProp}" />
// <Button Command="{Binding ViewModel.LoadDataCommand}" />
```

---

## Navigation

NavigationView is built entirely in `MainWindow.BuildNavigationView()` (code-behind) because
the raw XAML parser (`DisableXbfGeneration=true`) does not correctly wire NavigationView's
internal click-to-selection routing. API-created controls work correctly.

Tag → Page mapping in `MainWindow.NavigateToPage()`:
- `"dashboard"` → `DashboardPage`
- `"explorer"` → `ExplorerPage`
- `"groups"` → `GroupsPage`
- `"directories"` → `DirectoriesPage`
- `"settings"` → `SettingsPage` (triggered by `IsSettingsSelected`, not a menu tag)

Pages receive parameters via `OnNavigatedTo(NavigationEventArgs e)`:
- `GroupsPage` receives a search string
- `ExplorerPage` receives a directory path string

Search box (300ms debounce): choosing a suggestion navigates to `ExplorerPage(parentDir)`;
submitting text navigates to `GroupsPage(searchText)`.

Keyboard accelerators (wired in MainWindow constructor):
- `Ctrl+Z` → Undo
- `Ctrl+Y` / `Ctrl+Shift+Z` → Redo
- `Ctrl+D` → Open Deletion Review dialog
- `F5` → Refresh (re-navigate to current page type)

---

## Session Management

`ScanService.ActiveSessionId` (`long?`) is the central scope for all per-session queries.
When it changes, `ScanService.ActiveSessionChanged` (an `EventHandler<long?>`) fires.
All pages displaying per-session data subscribe to this event.

Progress callbacks from the Rust native library arrive on a Rust thread.
`ScanService` marshals them to the UI thread via `DispatcherQueue.TryEnqueue`.
The DispatcherQueue is set in `App.OnLaunched` after the window is created:
```csharp
scanService.SetDispatcherQueue(MainWindow.DispatcherQueue);
```

---

## Database — C# Side

`DatabaseService` owns three tables created by `EnsureSchemaAsync()` (called at app launch):
- `review_decisions (id, file_id, group_id, action, decided_at, session_id)`
- `undo_log (id, action_type, payload, created_at, reversed)`
- `scan_profiles (id, name, data, updated_at)`

Rust owns: `scan_session`, `scanned_file`, `duplicate_group`, `duplicate_group_member`,
`directory_node`, `directory_fingerprint`, `directory_similarity`, `deletion_plan`.

Both open `super_duper.db` in the working directory. WAL mode (set by Rust on first open)
allows concurrent reads. `DatabaseService` sets `PRAGMA busy_timeout=5000` and uses a
`SemaphoreSlim` for write serialization on the C# side.

---

## How to Add a New Page

1. Create `Views/MyPage.xaml` — standard WinUI 3 Page XAML.
   **Do NOT add event handler attributes outside DataTemplate blocks.**

2. Create `Views/MyPage.xaml.cs`:
```csharp
public sealed partial class MyPage : Page
{
    public MyPageViewModel ViewModel { get; }

    public MyPage()
    {
        this.InitializeComponent();
        XamlHelper.ConnectNamedElements(this, this);
        ViewModel = App.Services.GetRequiredService<MyPageViewModel>();
        this.DataContext = this;

        // Wire ALL non-DataTemplate events here — never in XAML attributes
        MyButton.Click += MyButton_Click;
        MyList.SelectionChanged += MyList_SelectionChanged;
    }

    protected override void OnNavigatedTo(NavigationEventArgs e)
    {
        base.OnNavigatedTo(e);
        if (e.Parameter is string param) { /* handle */ }
        var sessionId = App.Services.GetRequiredService<ScanService>().ActiveSessionId ?? 0;
        _ = ViewModel.LoadAsync(sessionId);
    }
}
```

3. Create `ViewModels/MyPageViewModel.cs`:
```csharp
public partial class MyPageViewModel : ObservableObject
{
    [ObservableProperty]
    public partial ObservableCollection<MyItem> Items { get; set; } = [];

    [RelayCommand]
    private async Task LoadAsync(long sessionId) { ... }
}
```

4. Register as Transient in `App.ConfigureServices()`:
```csharp
services.AddTransient<MyPageViewModel>();
```

5. Add nav item in `MainWindow.BuildNavigationView()`:
```csharp
NavView.MenuItems.Add(CreateNavItem("My Page", "mypage", Symbol.Document, "My Page — description"));
```

6. Add tag mapping in `MainWindow.NavigateToPage()`:
```csharp
"mypage" => typeof(MyPage),
```

---

## How to Add a New UserControl

1. Create `Controls/MyControl.xaml` + `.xaml.cs`.

2. Constructor pattern:
```csharp
public sealed partial class MyControl : UserControl
{
    // Custom event exposed to parent — parent wires this in its own constructor
    public event EventHandler<MyEventArgs>? ItemSelected;

    public MyControl()
    {
        this.InitializeComponent();
        XamlHelper.ConnectNamedElements(this, this);
        this.DataContext = this;

        // Wire internal events here — never in XAML
        InternalButton.Click += InternalButton_Click;
    }
}
```

3. In the consuming page's constructor:
```csharp
MyControlInstance.ItemSelected += MyControl_ItemSelected;
```

Never wire custom UserControl events as XAML attributes on the control element.

---

## Styles and Resources

All styles and resources declared in `App.xaml` (merged from `Colors.xaml` and `SharedStyles.xaml`).
Do not declare styles in page-level `ResourceDictionary` entries.

Named styles:
- `PathTextStyle` — `TargetType="TextBlock"`, Consolas 11pt, wrapping. Use for file system paths.
- `CardBorderStyle` — `TargetType="Border"`, 8px corner radius, 16px padding. Use for content cards.

Converters are instances in `App.xaml` resources; referenced by `x:Key` in bindings.

---

## Known Pitfalls

- **`FindName()` in flyouts** — Items inside `MenuFlyout`/`ContextFlyout` are not in the visual
  tree at construction time. Wire them in a `Loaded` event handler. See `GroupsPage` for the
  established pattern (`WireNonVisualTreeEvents()`).

- **`Application.Resources`** — getter/setter throw `COMException`. Set all resources from XAML only.

- **`Window.Title`** — must be set in code-behind (`Title = "..."`), not in XAML.

- **Two-level binding paths through services** — e.g. `{Binding ViewModel.ScanService.Phase}`
  can fail to update. Wire such properties explicitly via `PropertyChanged` subscriptions in
  code-behind. See `DashboardPage` for the pattern.

- **`SplitButton` flyout items** — same flyout visibility issue as `MenuFlyout`. Use `Loaded`
  event then `FindName()`. See `GroupsPage.WireNonVisualTreeEvents()`.

- **`NavigationView` in XAML** — the raw parser does not wire click-to-selection routing.
  Always build `NavigationView` instances in code-behind (see `MainWindow.BuildNavigationView()`).
